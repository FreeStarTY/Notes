
## 1. Quicksort 快速排序
- **思路**：  
  对于一个未排序片段，随机选择一个位置作为中枢点（pivot）。  
  - 将所有比 pivot 小的数放在左边，比 pivot 大的数放在右边  
  - 递归对左右子区间继续进行快速排序  

- **复杂度分析**：  
  - 平均复杂度：$O(n \log n)$  
  - 最坏情况：$O(n^2)$（当 pivot 选取极端时）

### 代码实现
```python
import random
from typing import List

def quickSort(nums: List[int], l: int, r: int) -> None:
    # 初始条件 l = 0, r = n - 1
    if l >= r:
        return

    pivot = random.randint(l, r)  # 随机选择 pivot
    pivot_val = nums[pivot]

    # 将 pivot 移到开头
    nums[l], nums[pivot] = nums[pivot], nums[l]

    i, j = l + 1, r
    while True:
        while i < j and nums[j] >= pivot_val:  # 从右找比 pivot 小的
            j -= 1
        while i < j and nums[i] <= pivot_val:  # 从左找比 pivot 大的
            i += 1
        if i >= j:
            break
        # 交换不满足条件的元素
        nums[i], nums[j] = nums[j], nums[i]

    # 将 pivot 放到正确位置
    new_pivot = i if nums[i] <= nums[l] else i - 1
    nums[l], nums[new_pivot] = nums[new_pivot], nums[l]

    # 递归排序两侧
    quickSort(nums, l, new_pivot - 1)
    quickSort(nums, new_pivot + 1, r)
```

---

## 2. Merge Sort 归并排序

- **思路**：  
    采用“分治”思想：
    
    - 先递归将数组左右两半分别排序
        
    - 再合并两个有序数组
        
- **复杂度分析**：
    
    - 时间复杂度：$O(n \log n)$（递归深度 $\log n$，每层合并 $O(n)$）
        
    - 空间复杂度：$O(n)$（需要辅助数组存放中间结果）
        

### 代码实现

```python
from typing import List

def mergeSort(nums: List[int], cache: List[int], l: int, r: int) -> None:
    # 初始条件 l = 0, r = n - 1
    if l >= r:
        return

    # 分
    mid = (l + r) // 2
    mergeSort(nums, cache, l, mid)
    mergeSort(nums, cache, mid + 1, r)

    # 治（合并）
    i, j = l, mid + 1
    for pos in range(l, r + 1):
        if j > r or (i <= mid and nums[i] <= nums[j]):
            cache[pos] = nums[i]
            i += 1
        else:
            cache[pos] = nums[j]
            j += 1
    nums[l:r + 1] = cache[l:r + 1]
```


